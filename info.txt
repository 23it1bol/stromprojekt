GET /api/kunden → Liste aller Kunden

POST /api/kunden → Neuen Kunden anlegen

GET /api/rechnungen/:id → Einzelne Rechnung abrufen

POST /api/anlage/:id/wartung → Wartung eintragen

src -> source

Ordner models/
Enthält Definitionen für die Datenstrukturen (Tabellen).
Beispiel: Kunde.ts, Zaehler.ts, Verbrauch.ts
Warum:
Typen/Interfaces stellen sicher, dass die Daten korrekt verwendet werden
Später kann man diese direkt für DB-Queries, Controller oder Validierungen verwenden


Ordner controllers/
Enthält die Logik für jede Ressource
Beispiel: kundenController.ts
Warum:
Trennt “was passiert mit den Daten” von “wie die Daten empfangen werden”
Hilft bei sauberem, prüfungsfreundlichem Aufbau

Ordner utils/
Für Hilfsfunktionen, die in mehreren Dateien benutzt werden
Beispiel: auditLogger.ts
Warum:
Code nicht mehrfach schreiben, sauber wiederverwenden
Prüferfreundlich: du kannst klar erklären, Audit-Log ist zentral

src = alles, was programmiert wird
models = Definitionen der Daten
controllers = Logik, was mit den Daten passiert
routes = REST-Endpunkte für Frontend/Client
utils = Hilfsfunktionen wie Audit-Logger
index.ts = Startpunkt des Servers

target: "ES2020" → sagt TypeScript, dass der Output JavaScript für die ES2020-Version sein soll.

module: "CommonJS" → Node.js verwendet CommonJS-Module (require/exports).

moduleResolution: "node" → sagt TypeScript, wie es Module finden soll.

outDir: "dist" → kompilierte JS-Dateien werden dort abgelegt, wenn du tsc ausführst.

rootDir: "src" → Quellcode liegt im src/ Ordner.

strict: true → strenge Typprüfung, gut für Anfänger, Fehler werden früher erkannt.

esModuleInterop: true → erlaubt, Default-Importe wie import express from "express" zu nutzen, auch wenn das Original CommonJS ist.

import express from "express";
→ Lädt das Express-Modul, um Webserver-Funktionen zu nutzen.

const app = express();
→ Erstellt eine Instanz des Express-Servers.

const port = 3000;
→ Port, auf dem der Server läuft. Standard ist oft 3000.

app.get("/test", (req, res) => res.send("OK"));
→ Erstellt eine Route, also eine URL, die reagiert.

/test → Pfad, den der Browser oder Postman aufruft

(req, res) => res.send("OK") → Callback-Funktion, die "OK" zurückgibt

app.listen(port, () => { console.log(...); });
→ Startet den Server und zeigt in der Konsole an, dass er läuft.